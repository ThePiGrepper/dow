Initializing a Mirrored Repository

$ mkdir <mirror-dir>
$ cd <mirror-dir>
$ ln -s <this-dir> srcdir
$ ./srcdir/dow-init cvs
$ echo "CVS.ROOTPATH=<cvs-root-path>" > config
$ echo "CVS.MODULEPATH=<cvs-root-path>/<module>" >> config
$ cd cvs_repo
$ export CVS_ROOT=<cvs-root-path>
$ cvs checkout <module> # as desired


Generating Modification Commits

Go to data repository (<mirror-dir>/data).
Commit and branch as usual (merges not supported).


Generating Synchronization Commits

Go to versions repository (<mirror-dir>/versions).
Create files. Fill them with valid version numbers.
  * Inspect the CVS repository (<mirror-dir>/cvs_repo) to see what versions
    are available for each file.
Commit and branch as usual.


Generating Synchronization Merges

Just use the option --no-commit when invoking git-merge. Then commit with
git-commit, so that the commit hooks are invoked.


Synchronization Commit from CVS state

Populate the CVS repository (<mirror-dir>/cvs_repo) as desired, e.g.:

$ cd <mirror-dir>/cvs_repo
$ cvs update -r <tag>

In the versions repository, checkout the desired branch, .e.g.:

$ cd ../versions
$ git checkout master

In the root directory, invoke the cvs_cmd/copy_tree script:

$ cd ..
$ ./cvs_cmd/copy_tree

The script writes the versions of the currently checked out files in CVS
to the index of the versions repository. You can inspect and even edit the
changes before generating the synchronization commit:

$ cd versions
$ git status
$ git diff --cached
$ git commit

To abort the operation:

$ cd <mirror-dir>/versions
$ git reset --hard

As an optional step, before applying the commit, you might want to find and
merge synchronization bases.

$ cd <mirror-dir>
$ ./srcdir/dow-sync-base

If there are any conflicts on the experimental merges generated you will have to
solve them and call

$ ./srcdir/dow-sync-base--continue

If you want to mark a merge as unresolvable:

$ ./srcdir/dow-sync-base--continue --bad

If you want to abort the operation:

$ ./srcdir/dow-sync-base--abort

If you complete the operation, you might either commit the CVS state as a merge:

$ cp dow-sync-base-result versions/.git/MERGE_HEAD
$ cd versions
$ git commit

Or generate a merge and then commit the state:

$ cd versions
$ git stash
$ git merge --no-commit `cat ../dow-sync-base-result` # if non-empty
$ git commit # if not a fast-forward
$ git stash pop
$ git commit # if there are any remaining changes


Working with a plain Git repository

Clone and pull from the data repository as usual.

$ git clone <mirror-dir>/data <local-repo>

When you want to publish your work, call a pull script from the data repository:

$ cd <mirror-dir>/data
$ ../utils/git_pull <local-repo> <branch>

The script will fetch your branch and simulate modification commits from your
changes. If a commit fails to apply (e.g., because it modifies an outdated
file), the branch is not updated.


Expected Results

Data repository (<mirror-dir>/data) should contain a history isomorph to the one
in the versions repository. File contents in the data repository should reflect
the version numbers used as file contents in the versions repository, as mapped
by the CVS repository.


Known Issues

* Commits with files given on the command line (e.g. "git commit -- file") are
  not supported. Apply the changes to the index and then commit without these
  arguments.

* Modification merges are not currently supported.

